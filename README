Linux system calls for LuaJIT

Unfinished! Many syscalls missing, work in progress!

What? An FFI implementation of the Linux system calls for LuaJIT.

Why? Making a C library for everything you want to bind is a pain, so I thought I would see what you could do without, and I want to do some low level system stuff in Lua.

Linux only? Easy to port to other Unixes, you need to check the types and constants are correct, and remove anything that is not in your C library (that applies also to any non glibc library too), and test. Patches accepted.

Requirements: Needs git head of LuaJIT (or next release 2.0.0-beta8 when it is out).

API

Basically what you expect, with the following notes. In general we explicitly return return parameters as it is more idiomatic.

All functions return three values, the return value, or true if there is not one other than success, then an error string, then the errno. The string and errno will be nil if there is no error. This makes it easy to write things like assert(fd:close()).

File descriptors are returned as a type not an integer. This is because they are garbage collected by default, ie if they go out of scope the file is closed. You can get the file descriptor using the fd field. To disable the garbage collection you can call fd:nogc(), in which case you need to close the descriptors by hand. They also have methods for operations that take an fd, like close, fsync, read. You can use this type where an fd is required, or a numeric fd, or a string like "stderr". 

String conversions are not done automatically, you get a buffer back, you have to force a conversion. This is because interning strings is expensive if you do not need it. Nor are conversions from 64 bit values to Lua numbers, as that would be lossy.

Not yet supporting the 64 bit file operations for 32 bit architectures (lseek64 etc).

Constants should all be available, eg L.SEEK_SET etc. You can usually add to combine them. May add some string parsing later.

You do not need to use the numbered versions of functions, eg dup can do dup2 or dup3 by adding more arguments

Note that pipe returns two file descriptors, rather than passing an array as in C, so fd0, fd1, err = L.pipe()

getcwd returns the result in a buffer if one is passed, or as a Lua string otherwise, ie if called with no parameters/

The stat type adds convenience methods corresponding to the standard macros, note the methods are on the overall type, not on the methods, eg stat:major() to get major number of device.

Testing

The test script is quite comprehensive, though it does not test all the syscalls, as I assume they work, but it should stress the bindings. Tested on ARM, amd64, x86.

